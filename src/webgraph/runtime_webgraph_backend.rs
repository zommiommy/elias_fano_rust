//! THIS FILE IS AUTOMATICALLY GENERATED FROM build.rs DO NOT MODIFY IT HERE
use super::*;

/// WebGraph reader that on initializzation does a single static dispatch of
/// the codes. This implements the trait WebGraphReader which returns a new
/// reader which handles the dispatching of the right code for each step.
/// This dispatching is inherited by the readers, so the instantiation of
/// a reader is just a memcpy of the parameters so it should be only slightly
/// slower than the constant time dispatcher (but indirection always has an
/// overhead)
pub struct RuntimeWebGraphReader<Backend: CodesReader> {
    backend: Backend,
    settings: CodesSettings,
}

impl<Backend: CodesReader> RuntimeWebGraphReader<Backend> {
    #[inline]
    pub fn new(settings: CodesSettings, backend: Backend) -> Self {
        RuntimeWebGraphReader {
            backend,
            settings,
        }
    }

    #[inline]
    /// wrap a reader so that it dispatch the codes
    pub fn wrap<'a>(
        &self,
        reader: Backend::CodesReaderType<'a>,
    ) -> RuntimeWebGraphReaderBackend<Backend::CodesReaderType<'a>> {
        RuntimeWebGraphReaderBackend {
            reader,
            settings: self.settings.clone(), // TODO!: remove this clone
        }
    }
}

impl<Backend: CodesReader> WebGraphReader for RuntimeWebGraphReader<Backend> {
    type WebGraphReaderType<'a> = RuntimeWebGraphReaderBackend<Backend::CodesReaderType<'a>>
    where Self: 'a;

    #[inline]
    fn get_reader(&self, offset: usize) -> Self::WebGraphReaderType<'_> {
        self.wrap((&self.backend).get_codes_reader(offset))
    }
}

/// Actual Reader that without any dispatching can use the right codes
pub struct RuntimeWebGraphReaderBackend<READER: CodesRead> {
    reader: READER,
    settings: CodesSettings,
}

macro_rules! impl_read_match {
    ($func_name:ident, $attribute:ident) => {
        #[inline]
        fn $func_name(&mut self) -> Result<usize> {
            match self.settings.$attribute {
                Code::Unary => self.reader.read_unary(),
                Code::Gamma => self.reader.read_gamma(),
                Code::Delta => self.reader.read_delta(),
                Code::Golomb(b) => self.reader.read_golomb_runtime(b),
                Code::Zeta(k) => self.reader.read_zeta_runtime(k),
                _ => unimplemented!("The wanted code is not implemented yet."),
            }
        }
    };
}

impl<READER> WebGraphReaderBackend for RuntimeWebGraphReaderBackend<READER>
where
    READER: CodesRead,
{
    impl_read_match!(read_outdegree, outdegree);
    impl_read_match!(read_reference_offset, reference_offset);
    impl_read_match!(read_block_count, block_count);
    impl_read_match!(read_blocks, blocks);
    impl_read_match!(read_interval_count, interval_count);
    impl_read_match!(read_interval_start, interval_start);
    impl_read_match!(read_interval_len, interval_len);
    impl_read_match!(read_first_residual, first_residual);
    impl_read_match!(read_residual, residual);
}

impl<READER> crate::traits::ReadBit for RuntimeWebGraphReaderBackend<READER>
where
    READER: CodesRead,
{
    #[inline]
    fn read_bit(&mut self) -> Result<bool> {
        self.reader.read_bit()
    }
    
    #[inline]
    fn peek_byte(&mut self) -> Result<u8> {
        self.reader.peek_byte()
    }

    #[inline]
    fn seek_bits(&mut self, bit_offset: usize) -> Result<()> {
        self.reader.seek_bits(bit_offset)
    }

    #[inline]
    fn tell_bits(&self) -> Result<usize> {
        self.reader.tell_bits()
    }
}
