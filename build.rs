use std::io::Write;

const SETTINGS: &[&str] = &[
    "outdegree",
    "reference_offset",
    "block_count",
    "blocks",
    "interval_count",
    "interval_start",
    "interval_len",
    "first_residual",
    "residual",
];

fn main() {
    println!("cargo:rerun-if-changed=./build.rs");
    let content = format!(
        r#"
//! THIS FILE IS AUTOMATICALLY GENERATED FROM build.rs DO NOT MODIFY IT HERE
use super::*;
use crate::traits::MemoryFootprint;

/// WebGraph reader that on initializzation does a single static dispatch of
/// the codes. This implements the trait WebGraphReader which returns a new
/// reader which handles the dispatching of the right code for each step.
/// This dispatching is inherited by the readers, so the instantiation of
/// a reader is just a memcpy of the parameters so it should be only slightly 
/// slower than the constant time dispatcher (but indirection always has an 
/// overhead)
pub struct RuntimeWebGraphReader<'a, BACKEND: CodesReader<'a> + MemoryFootprint>{{
    backend: BACKEND,
    settings: CodesSettings,
    // Virtual table for the instances methods, this allows to do the 
    // dispatching exactly once
    {params_definition}
    {params_codes_definiton}
}}

impl<'a, BACKEND> MemoryFootprint for RuntimeWebGraphReader<'a, BACKEND>
where
    BACKEND: CodesReader<'a> + MemoryFootprint
{{
    fn total_size(&self) -> usize {{
        self.backend.total_size()
            + self.settings.total_size() 
            {footprint}
    }}
}}


impl<'a, BACKEND> RuntimeWebGraphReader<'a, BACKEND>
where
    BACKEND: CodesReader<'a> + MemoryFootprint 
{{
    pub fn new(settings: CodesSettings, backend: BACKEND) -> Self {{
        {code_dispatcher}

        RuntimeWebGraphReader{{
            backend,
            settings,
            {params}
            {codes}
        }}
    }}

    /// wrap a reader so that it dispatch the codes
    pub fn wrap(&self, reader: BACKEND::CodesReaderType) 
        -> RuntimeWebGraphReaderBackend<BACKEND::CodesReaderType> {{
        RuntimeWebGraphReaderBackend{{
            reader,
            {self_params}
            {self_codes}
        }}
    }}
}}

impl<'a, BACKEND> WebGraphReader<'a> for RuntimeWebGraphReader<'a, BACKEND> 
where
    BACKEND: CodesReader<'a> + MemoryFootprint
{{
    type ReaderType = RuntimeWebGraphReaderBackend<BACKEND::CodesReaderType>;
    fn get_reader(&'a self, offset: usize) -> Self::ReaderType {{
        self.wrap(self.backend.get_codes_reader(offset))
    }}
}}

/// Actual Reader that without any dispatching can use the right codes
pub struct RuntimeWebGraphReaderBackend<READER: CodesRead + MemoryFootprint> {{
    reader: READER,
    {params_definition}
    {params_codes_definiton_reader}
}}

impl<READER> MemoryFootprint for RuntimeWebGraphReaderBackend<READER> 
where
    READER: CodesRead + MemoryFootprint
{{
    #[inline]
    fn total_size(&self) -> usize {{
        self.reader.total_size()
            + self.reader.total_size() 
            {footprint}
    }}
}}

impl<READER> RuntimeWebGraphReaderBackend<READER> 
where
    READER: CodesRead + MemoryFootprint
{{
    #[inline]
    fn read_unary(&mut self) -> Result<usize> {{
        self.reader.read_unary()
    }}

    #[inline]
    fn read_gamma(&mut self) -> Result<usize> {{
        self.reader.read_gamma()
    }}

    #[inline]
    fn read_delta(&mut self) -> Result<usize> {{
        self.reader.read_delta()
    }}

    {code_impls}
}}

impl<READER> WebGraphReaderBackend for RuntimeWebGraphReaderBackend<READER> 
where
    READER: CodesRead + MemoryFootprint
{{
    {trait_impl}
}}

impl<READER> crate::traits::ReadBit
for RuntimeWebGraphReaderBackend<READER>
where
    READER: CodesRead + MemoryFootprint
{{
    #[inline]
    fn read_bit(&mut self) -> Result<bool> {{
        self.reader.read_bit()
    }}

    #[inline]
    fn seek_bits(&mut self, bit_offset: usize) -> Result<()> {{
        self.reader.seek_bits(bit_offset)
    }}

    #[inline]
    fn tell_bits(&self) -> Result<usize> {{
        self.reader.tell_bits()
    }}
}}
"#,
        footprint = (0..2 * SETTINGS.len())
            .map(|_| "+ std::mem::size_of::<usize>()")
            .collect::<Vec<_>>()
            .join("\n"),
        params_definition = SETTINGS
            .iter()
            .map(|x| format!("{}_param: usize,", x))
            .collect::<Vec<_>>()
            .join("\n"),
        params_codes_definiton = SETTINGS
            .iter()
            .map(|x| format!(
                "{}_code: fn(inner: &mut RuntimeWebGraphReaderBackend<BACKEND::CodesReaderType>) -> Result<usize>,",
                x
            ))
            .collect::<Vec<_>>()
            .join("\n"),
        params_codes_definiton_reader = SETTINGS
            .iter()
            .map(|x| format!(
                "{}_code: fn(inner: &mut RuntimeWebGraphReaderBackend<READER>) -> Result<usize>,",
                x
            ))
            .collect::<Vec<_>>()
            .join("\n"),
        params = SETTINGS
            .iter()
            .map(|x| format!("{}_param,", x))
            .collect::<Vec<_>>()
            .join("\n"),
        codes = SETTINGS
            .iter()
            .map(|x| format!("{}_code,", x))
            .collect::<Vec<_>>()
            .join("\n"),
        self_params = SETTINGS
            .iter()
            .map(|x| format!("{}_param: self.{}_param,", x, x))
            .collect::<Vec<_>>()
            .join("\n"),
        self_codes = SETTINGS
            .iter()
            .map(|x| format!("{}_code: self.{}_code,", x, x))
            .collect::<Vec<_>>()
            .join("\n"),
        code_dispatcher = SETTINGS
            .iter()
            .map(|x| format!(
                r#"
let ({}_code, {}_param) = match settings.{} {{
    Code::Unary     => (RuntimeWebGraphReaderBackend::read_unary as _, 0),
    Code::Gamma     => (RuntimeWebGraphReaderBackend::read_gamma as _, 0),
    Code::Delta     => (RuntimeWebGraphReaderBackend::read_delta as _, 0),
    Code::Golomb(B) => (RuntimeWebGraphReaderBackend::{}_golomb as _, B),
    Code::Zeta(K)   => (RuntimeWebGraphReaderBackend::{}_zeta as _, K),
    _ => unimplemented!("The wanted code is not implemented yet."),
}};     
        "#,
                x, x, x, x, x
            ))
            .collect::<Vec<_>>()
            .join("\n"),
        code_impls = SETTINGS
            .iter()
            .map(|x| format!(
                r#"
fn {}_golomb(&mut self) -> Result<usize> {{
    self.reader.read_golomb_runtime(self.{}_param)
}}

fn {}_zeta(&mut self) -> Result<usize> {{
    self.reader.read_zeta_runtime(self.{}_param)
}}
"#,
                x, x, x, x
            ))
            .collect::<Vec<_>>()
            .join("\n"),
        trait_impl = SETTINGS
            .iter()
            .map(|x| format!(
                r#"
fn read_{}(&mut self) -> Result<usize> {{
    (self.{}_code)(self)
}}"#,
                x, x
            ))
            .collect::<Vec<_>>()
            .join("\n"),
    );

    let mut file = std::fs::File::create("./src/webgraph/runtime_webgraph_backend.rs").unwrap();
    file.write_all(content.as_bytes()).unwrap();

    assert!(
        std::process::Command::new("cargo")
            .args(&["fmt"])
            .current_dir(".")
            .status()
            .expect("Could not run format on the python bindings")
            .success(),
        "The cargo format failed and returned non-zero exit status"
    );
}
